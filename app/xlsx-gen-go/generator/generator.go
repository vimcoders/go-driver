package generator

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	"github.com/tealeg/xlsx/v3"
)

type Sheet struct {
	*xlsx.Sheet
	FileName string
}

func NewSheet(s *xlsx.Sheet) *Sheet {
	return &Sheet{
		Sheet: s,
	}
}

type Header struct {
	index   int
	title   string
	comment string
}

const (
	TitleRow   = 0
	CommentRow = 2
)

func (s *Sheet) GetTitle() []*Header {
	title, err := s.Row(TitleRow)
	if err != nil {
		panic(err)
	}
	commRow, err := s.Row(CommentRow)
	if err != nil {
		panic(fmt.Errorf("%s[%s] Get Comment Row(4) failed:%v", s.FileName, s.Name, err))
	}
	index := 0
	var titles []*Header
	title.ForEachCell(func(c *xlsx.Cell) error {
		if len(c.Value) <= 0 {
			index++
			return nil
		}
		if strings.Index(c.Value, "c_") == 0 {
			index++
			return nil
		}
		titles = append(titles, &Header{
			index: index,
			title: c.String(),
		})
		index++
		return nil
	})
	// 获取注释信息
	for _, v := range titles {
		comm := commRow.GetCell(v.index).String()
		comm = strings.Replace(comm, "\r", ";", -1)
		comm = strings.Replace(comm, "\n", ";", -1)
		v.comment = strings.TrimSpace(comm)
	}
	return titles
}

func (s *Sheet) marshal(r *xlsx.Row) map[string]interface{} {
	result := make(map[string]interface{})
	typeRow, err := s.Row(TitleRow)
	if err != nil {
		panic(err)
	}
	for _, h := range s.GetTitle() {
		dd := r.GetCell(h.index).String()
		if strings.ToLower(h.title) == "id" && len(dd) <= 0 {
			return nil
		}
		var TYPE = strings.ToLower(typeRow.GetCell(h.index).String())
		switch {
		case strings.Contains(TYPE, "int"), TYPE == "":
			if n, err := strconv.Atoi(dd); err == nil {
				result[h.title] = n
			}
		default:
			result[h.title] = dd
		}
	}
	return result
}

func (s *Sheet) MarshalTo(w io.Writer) error {
	var result []map[string]interface{}
	for i := CommentRow + 1; i < s.MaxRow; i++ {
		row, err := s.Row(i)
		if err != nil {
			return err
		}
		data := s.marshal(row)
		if len(data) <= 0 {
			continue
		}
		result = append(result, s.marshal(row))
	}
	b, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		return err
	}
	if _, err := w.Write(b); err != nil {
		return err
	}
	return nil
}

func (s *Sheet) WriteTo(w io.Writer) (int64, error) {
	var builder strings.Builder
	builder.WriteString("// Code generated by conf.exe. DO NOT EDIT.\n")
	builder.WriteString(fmt.Sprintf("// Source: <<%s>> [%s]\n\n", s.FileName, s.Name))
	builder.WriteString("package conf\n")
	builder.WriteString(fmt.Sprintf("type %vRow struct{\n", strings.ToUpper(s.Name)))
	row, err := s.Row(2)
	if err != nil {
		return 0, err
	}
	for _, v := range s.GetTitle() {
		var k = v.title
		switch {
		case strings.Contains(strings.ToLower(row.GetCell(v.index).Value), "int"):
			builder.WriteString(fmt.Sprintf("%v int `%v`", strings.ToUpper(k), fmt.Sprintf(`json:"%v"`, k)))
		case len(row.GetCell(v.index).Value) <= 0:
			builder.WriteString(fmt.Sprintf("%v int `%v`", strings.ToUpper(k), fmt.Sprintf(`json:"%v"`, k)))
		default:
			builder.WriteString(fmt.Sprintf("%v string `%v`", strings.ToUpper(k), fmt.Sprintf(`json:"%v"`, k)))
		}
		builder.WriteString("// ")
		builder.WriteString(v.comment)
		builder.WriteString("\n")
	}
	builder.WriteString("}\n")
	builder.WriteString(fmt.Sprintf("type %vTable struct {data []*%vRow\n", strings.ToUpper(s.Name), strings.ToUpper(s.Name)))
	builder.WriteString("}\n")
	builder.WriteString(fmt.Sprintf("var %vConf %vTable\n", strings.ToUpper(s.Name), strings.ToUpper(s.Name)))
	builder.WriteString(fmt.Sprintf("func (x *%vTable) load() {\n", strings.ToUpper(s.Name)))
	builder.WriteString(fmt.Sprintf("b, err := os.ReadFile(`%v`)\n", "./conf/json/"+s.Name+".json"))
	builder.WriteString("if err != nil {")
	builder.WriteString("panic(err)\n")
	builder.WriteString("}\n")
	builder.WriteString("if err := json.Unmarshal(b, &x.data); err != nil {")
	builder.WriteString("panic(err)\n")
	builder.WriteString("}\n")
	builder.WriteString("}\n")
	var t template.Template
	t.Parse(builder.String())
	if err := t.Execute(w, nil); err != nil {
		return 0, err
	}
	return 0, nil
}

type Generator struct {
	Sheets []*Sheet
	*regexp.Regexp
}

func NewGenerator() (*Generator, error) {
	var g Generator
	fileInfo, err := os.ReadDir("./conf/xlsx")
	if err != nil {
		return nil, err
	}
	for _, v := range fileInfo {
		if ok := v.IsDir(); ok {
			continue
		}
		fileName := fmt.Sprintf("./conf/xlsx/%v", v.Name())
		log.Printf("read-sheet: %s", fileName)
		file, err := xlsx.OpenFile(fileName)
		if err != nil {
			panic(err)
		}
		for _, s := range file.Sheets {
			g.Sheets = append(g.Sheets, &Sheet{
				Sheet:    s,
				FileName: v.Name(),
			})
		}
	}
	g.Regexp = regexp.MustCompile(`^[a-zA-Z]*(_[a-zA-Z]+)*$`)
	return &g, nil
}

func (g *Generator) Gen() error {
	loadfile, err := os.Create("./conf/load.go")
	if err != nil {
		return err
	}
	defer loadfile.Close()
	var builder strings.Builder
	builder.WriteString("package conf\n")
	// builder.WriteString("func init(){Load()}\n")
	builder.WriteString("func Load(){\n")
	for _, v := range g.Sheets {
		if ok := g.Match([]byte(v.Name)); !ok {
			continue
		}
		if ok := strings.Contains(strings.ToLower(v.Name), "sheet"); ok {
			continue
		}
		jsonFile, err := os.Create(fmt.Sprintf("./conf/json/%v.json", v.Name))
		if err != nil {
			return err
		}
		defer jsonFile.Close()
		if err := v.MarshalTo(jsonFile); err != nil {
			return err
		}
		codefile, err := os.Create(fmt.Sprintf("./conf/%v.go", v.Name))
		if err != nil {
			return err
		}
		defer codefile.Close()
		if _, err := v.WriteTo(codefile); err != nil {
			return err
		}
		builder.WriteString(fmt.Sprintf("%vConf.load()\n", strings.ToUpper(v.Name)))
	}
	builder.WriteString("}\n")
	var t template.Template
	t.Parse(builder.String())
	if err := t.Execute(loadfile, nil); err != nil {
		return err
	}
	return nil
}
